B[1,] = B[nburn,]
Z[1,] = Z[nburn,]
pr = cp/p
err.var[1] = err.var[nburn]
BB = B[1,]
ZZ = ZZ1 = apply(Z[1:nburn,],2,mean)
for(itr in 2:niter){
B[itr,]  = gib.betas(X,Y, B[(itr-1),], err.var[(itr-1)], Z[(itr-1),])
err.var[itr] = gib.sig(X, B[itr,], Z[(itr-1),])
Z[itr,] = gib.z(B[itr,], err.var[itr], pr)
Z[itr,1] = 1
#if(itr %%1000 ==0) print(itr)
}
if(returnB==0) {return(Z)}
if(returnB==1) {return(list(Z=Z,B=B))}
}
start.time = Sys.time()
bsd = basad(X,Y,Z0,returnB = 1,K = K,del = 0.1,sig = sighat)
end.time = Sys.time()
run.time = as.numeric(difftime(end.time, start.time, units = 'secs'))
run.time
basad <- function(X,Y,Z0,B0 = NULL,returnB = 0, K,del,sig,nburn = 1000, niter = 4000,nsplit = 1){
p = dim(X)[2]-1; n = dim(X)[1]
choicep <-function(x){
return(x - K + qnorm(0.9)*sqrt(x*(1- x/p)))
}
cp = uniroot(choicep, c(1,K))$root
pr = 0.1
s0 = 1/n
fvalue = dnorm(sqrt(2.1*log(p+1)))
s1  = max(100*s0, pr*s0/((1 - pr)*fvalue));
### nsplit is the number of iterative conditional normals
vsize = (p+1) %/%nsplit
G = t(X)%*%X
Phi = X/ sqrt(sig)
alpha = Y/ sqrt(sig)
gib.beta <- function(X, Y, B, sig, Z){
T1 = Z*s1 + (1-Z)*s0
vec = seq(1:vsize)
Xtmp = X
for(s in 1:nsplit){
svec = (s-1)*vsize +vec
COV = (G[svec,svec] + diag(1/T1[svec]))
ec = eigen(COV)
COVsq = ec$vectors %*% diag(1/sqrt(ec$values)) %*% t(ec$vectors)
B[svec] = COVsq %*% (COVsq %*% (t(X[,svec]) %*% Y - G[svec, -svec] %*% B[-svec]) + sqrt(sig)*rnorm(vsize))
}
return(B)
}
gib.betas <- function(X, Y, B, sig, Z){
T1 = Z * s1 + (1 - Z) * s0
D = sig * diag( T1 )
ev = eigen( D)
lambda <- ev$values
V = ev$vectors
R <- V %*% diag( sqrt(lambda) ) %*% t(V)
Z <- rnorm(p+1)
mu <-  R %*% Z
#mu = mvrnorm(1, t(array(0,p+1)), D)
delta = rnorm(n, 1)
nu = Phi %*% mu + delta
omega = solve( (Phi %*% D %*% t(Phi) + diag(n)), ( alpha - nu)   )
B = mu + D %*% t(Phi) %*% omega
return(B)
}
p1 = 10^-4; p2 = 10^-4                 ## Paramerers of IG distribution for Error variance
gib.sig <- function(X, B, Z){
T1 = Z*s1 + (1-Z)*s0
res = 1/rgamma(1, p1+ (n*0.5)+(p*0.5), p2+(0.5* t(Y - X %*% B)%*% (Y - X%*%B))+(0.5*t(B)%*%diag(1/T1)%*%B))
return(res)
}
gib.z <- function(B, sig, pr){
A = array(0, p+1)
s = seq(1:(p+1))
prob = sapply(s, function(j) pr* dnorm(B[j], 0, sqrt(sig*s1))/ (pr* dnorm(B[j], 0, sqrt(sig*s1))+ (1-pr)* dnorm(B[j], 0, sqrt(sig*s0))))
tmp = (runif((p+1)) - prob)
Z = (tmp <0);
if(sum(Z) > n/2) {
indz = which(Z ==1)
Z[indz[which(prob[Z] < rev(sort(prob[Z]))[round(n/2)])]] = 0}
return(Z)
}
## Gibbs algorithm
B = array(0, c(niter,p+1))
Z = array(0, c(niter,p+1))
Z[1,] = Z0
if(is.null(B0) ==FALSE) {B[1,] = B0}
err.var = array(0, niter)
pr = cp/p
err.var[1] = 1
for(brn in 2:nburn){
B[brn,]  = gib.betas(X,Y,  B[(brn-1),], err.var[(brn-1)], Z[(brn-1),])
err.var[brn] = gib.sig(X, B[brn,], Z[(brn-1),])
Z[brn,] = gib.z(B[brn,], err.var[brn], pr)
Z[brn,1] = 1
#if(brn %%1000 ==0) print(brn)
}
B[1,] = B[nburn,]
Z[1,] = Z[nburn,]
pr = cp/p
err.var[1] = err.var[nburn]
BB = B[1,]
ZZ = ZZ1 = apply(Z[1:nburn,],2,mean)
for(itr in 2:niter){
B[itr,]  = gib.betas(X,Y, B[(itr-1),], err.var[(itr-1)], Z[(itr-1),])
err.var[itr] = gib.sig(X, B[itr,], Z[(itr-1),])
Z[itr,] = gib.z(B[itr,], err.var[itr], pr)
Z[itr,1] = 1
#if(itr %%1000 ==0) print(itr)
}
if(returnB==0) {return(Z)}
if(returnB==1) {return(list(Z=Z,B=B))}
}
start.time = Sys.time()
bsd = basad(X,Y,Z0,returnB = 1,K = K,del = 0.1,sig = sighat)
end.time = Sys.time()
run.time = as.numeric(difftime(end.time, start.time, units = 'secs'))
run.time
basad <- function(X,Y,Z0,B0 = NULL,returnB = 0, K,del,sig,nburn = 1000, niter = 4000,nsplit = 1){
p = dim(X)[2]-1; n = dim(X)[1]
choicep <-function(x){
return(x - K + qnorm(0.9)*sqrt(x*(1- x/p)))
}
cp = uniroot(choicep, c(1,K))$root
pr = 0.1
s0 = 1/n
fvalue = dnorm(sqrt(2.1*log(p+1)))
s1  = max(100*s0, pr*s0/((1 - pr)*fvalue));
### nsplit is the number of iterative conditional normals
vsize = (p+1) %/%nsplit
G = t(X)%*%X
gib.beta <- function(X, Y, B, sig, Z){
T1 = Z*s1 + (1-Z)*s0
vec = seq(1:vsize)
Xtmp = X
for(s in 1:nsplit){
svec = (s-1)*vsize +vec
COV = (G[svec,svec] + diag(1/T1[svec]))
ec = eigen(COV)
COVsq = ec$vectors %*% diag(1/sqrt(ec$values)) %*% t(ec$vectors)
B[svec] = COVsq %*% (COVsq %*% (t(X[,svec]) %*% Y - G[svec, -svec] %*% B[-svec]) + sqrt(sig)*rnorm(vsize))
}
return(B)
}
gib.betas <- function(X, Y, B, sig, Z){
T1 = Z * s1 + (1 - Z) * s0
D = sig * diag( T1 )
Phi = X/ sqrt(sig)
alpha = Y/ sqrt(sig)
##mu = mvrnorm(1, t(array(0,p+1)), D)
mu = mvrnorm( p+1, rep(0, p+1), diag(D) )
delta = rnorm(n, 1)
nu = Phi %*% mu + delta
omega = solve( (Phi %*% D %*% t(Phi) + diag(n)), ( alpha - nu)   )
B = mu + D %*% t(Phi) %*% omega
return(B)
}
p1 = 10^-4; p2 = 10^-4                 ## Paramerers of IG distribution for Error variance
gib.sig <- function(X, B, Z){
T1 = Z*s1 + (1-Z)*s0
res = 1/rgamma(1, p1+ (n*0.5)+(p*0.5), p2+(0.5* t(Y - X %*% B)%*% (Y - X%*%B))+(0.5*t(B)%*%diag(1/T1)%*%B))
return(res)
}
gib.z <- function(B, sig, pr){
A = array(0, p+1)
s = seq(1:(p+1))
prob = sapply(s, function(j) pr* dnorm(B[j], 0, sqrt(sig*s1))/ (pr* dnorm(B[j], 0, sqrt(sig*s1))+ (1-pr)* dnorm(B[j], 0, sqrt(sig*s0))))
tmp = (runif((p+1)) - prob)
Z = (tmp <0);
if(sum(Z) > n/2) {
indz = which(Z ==1)
Z[indz[which(prob[Z] < rev(sort(prob[Z]))[round(n/2)])]] = 0}
return(Z)
}
## Gibbs algorithm
B = array(0, c(niter,p+1))
Z = array(0, c(niter,p+1))
Z[1,] = Z0
if(is.null(B0) ==FALSE) {B[1,] = B0}
err.var = array(0, niter)
pr = cp/p
err.var[1] = 1
for(brn in 2:nburn){
B[brn,]  = gib.betas(X,Y,  B[(brn-1),], err.var[(brn-1)], Z[(brn-1),])
err.var[brn] = gib.sig(X, B[brn,], Z[(brn-1),])
Z[brn,] = gib.z(B[brn,], err.var[brn], pr)
Z[brn,1] = 1
#if(brn %%1000 ==0) print(brn)
}
B[1,] = B[nburn,]
Z[1,] = Z[nburn,]
pr = cp/p
err.var[1] = err.var[nburn]
BB = B[1,]
ZZ = ZZ1 = apply(Z[1:nburn,],2,mean)
for(itr in 2:niter){
B[itr,]  = gib.betas(X,Y, B[(itr-1),], err.var[(itr-1)], Z[(itr-1),])
err.var[itr] = gib.sig(X, B[itr,], Z[(itr-1),])
Z[itr,] = gib.z(B[itr,], err.var[itr], pr)
Z[itr,1] = 1
#if(itr %%1000 ==0) print(itr)
}
if(returnB==0) {return(Z)}
if(returnB==1) {return(list(Z=Z,B=B))}
}
n =  100; p = 199
nz = 5
rho1=0.25;rho2=0.25;rho3=0.25  ### correlation among active, between active and inactive, inactive parts
Bc = c( 0,seq(0.6,3,length.out=nz), array(0, p-nz))
covr1=(1- rho1)*diag(nz) +  array(rho1,c(nz,nz))
covr3=(1- rho3)*diag(p-nz) +  array(rho3,c(p-nz,p-nz))
covr2=array(rho2,c(nz,p-nz))
covr=rbind(cbind(covr1,covr2),cbind(t(covr2),covr3))
covE = eigen(covr)
covsq = covE$vectors %*% diag(sqrt(covE$values)) %*% t(covE$vectors) #
K = 10   ## An initial reasonable choice for number of covariates in the model
Xs = matrix( rnorm(n*p), nrow = n)
Xn = covsq%*% t(Xs)
X = cbind(array(1, n), t(Xn))
Y = X %*% Bc + rnorm(n)
Bols = sapply(seq(1:(p+1)), function(j) summary(lm(Y~ 0+X[,j]))$coef[,1])
B0 = Bols
if(p > n) {m = round(p - (n/2))}
if(p <=n) m = round(p/2)
ind = which(abs(B0)> sort(abs(B0))[m+1])
sighat = sum((summary(lm(Y~0+X[,union(1,ind)]))$residuals)^2)/(n-length(union(1,ind)))
Z0 = array(0,(p+1))
start.time = Sys.time()
bsd = basad(X,Y,Z0,returnB = 1,K = K,del = 0.1,sig = sighat)
end.time = Sys.time()
basad <- function(X,Y,Z0,B0 = NULL,returnB = 0, K,del,sig,nburn = 1000, niter = 4000,nsplit = 1){
p = dim(X)[2]-1; n = dim(X)[1]
choicep <-function(x){
return(x - K + qnorm(0.9)*sqrt(x*(1- x/p)))
}
cp = uniroot(choicep, c(1,K))$root
pr = 0.1
s0 = 1/n
fvalue = dnorm(sqrt(2.1*log(p+1)))
s1  = max(100*s0, pr*s0/((1 - pr)*fvalue));
### nsplit is the number of iterative conditional normals
vsize = (p+1) %/%nsplit
G = t(X)%*%X
gib.beta <- function(X, Y, B, sig, Z){
T1 = Z*s1 + (1-Z)*s0
vec = seq(1:vsize)
Xtmp = X
for(s in 1:nsplit){
svec = (s-1)*vsize +vec
COV = (G[svec,svec] + diag(1/T1[svec]))
ec = eigen(COV)
COVsq = ec$vectors %*% diag(1/sqrt(ec$values)) %*% t(ec$vectors)
B[svec] = COVsq %*% (COVsq %*% (t(X[,svec]) %*% Y - G[svec, -svec] %*% B[-svec]) + sqrt(sig)*rnorm(vsize))
}
return(B)
}
gib.betas <- function(X, Y, B, sig, Z){
T1 = Z * s1 + (1 - Z) * s0
D = sig * diag( T1 )
Phi = X/ sqrt(sig)
alpha = Y/ sqrt(sig)
##mu = mvrnorm(1, t(array(0,p+1)), D)
mu = rnorm( p+1, rep(0, p+1), diag(D) )
delta = rnorm(n, 1)
nu = Phi %*% mu + delta
omega = solve( (Phi %*% D %*% t(Phi) + diag(n)), ( alpha - nu)   )
B = mu + D %*% t(Phi) %*% omega
return(B)
}
p1 = 10^-4; p2 = 10^-4                 ## Paramerers of IG distribution for Error variance
gib.sig <- function(X, B, Z){
T1 = Z*s1 + (1-Z)*s0
res = 1/rgamma(1, p1+ (n*0.5)+(p*0.5), p2+(0.5* t(Y - X %*% B)%*% (Y - X%*%B))+(0.5*t(B)%*%diag(1/T1)%*%B))
return(res)
}
gib.z <- function(B, sig, pr){
A = array(0, p+1)
s = seq(1:(p+1))
prob = sapply(s, function(j) pr* dnorm(B[j], 0, sqrt(sig*s1))/ (pr* dnorm(B[j], 0, sqrt(sig*s1))+ (1-pr)* dnorm(B[j], 0, sqrt(sig*s0))))
tmp = (runif((p+1)) - prob)
Z = (tmp <0);
if(sum(Z) > n/2) {
indz = which(Z ==1)
Z[indz[which(prob[Z] < rev(sort(prob[Z]))[round(n/2)])]] = 0}
return(Z)
}
## Gibbs algorithm
B = array(0, c(niter,p+1))
Z = array(0, c(niter,p+1))
Z[1,] = Z0
if(is.null(B0) ==FALSE) {B[1,] = B0}
err.var = array(0, niter)
pr = cp/p
err.var[1] = 1
for(brn in 2:nburn){
B[brn,]  = gib.betas(X,Y,  B[(brn-1),], err.var[(brn-1)], Z[(brn-1),])
err.var[brn] = gib.sig(X, B[brn,], Z[(brn-1),])
Z[brn,] = gib.z(B[brn,], err.var[brn], pr)
Z[brn,1] = 1
#if(brn %%1000 ==0) print(brn)
}
B[1,] = B[nburn,]
Z[1,] = Z[nburn,]
pr = cp/p
err.var[1] = err.var[nburn]
BB = B[1,]
ZZ = ZZ1 = apply(Z[1:nburn,],2,mean)
for(itr in 2:niter){
B[itr,]  = gib.betas(X,Y, B[(itr-1),], err.var[(itr-1)], Z[(itr-1),])
err.var[itr] = gib.sig(X, B[itr,], Z[(itr-1),])
Z[itr,] = gib.z(B[itr,], err.var[itr], pr)
Z[itr,1] = 1
#if(itr %%1000 ==0) print(itr)
}
if(returnB==0) {return(Z)}
if(returnB==1) {return(list(Z=Z,B=B))}
}
start.time = Sys.time()
bsd = basad(X,Y,Z0,returnB = 1,K = K,del = 0.1,sig = sighat)
end.time = Sys.time()
bsd$Z
bsd$B
bsd$B[,2:6]
install.packages("Rcpp")
library("Rcpp")
sourceCpp("/Users/Qingyan/Documents/research/0605/testNew2.cpp")
n =  50; p = 49
nz = 5
rho1=0.25;rho2=0.25;rho3=0.25  ### correlation among active, between active and inactive, inactive parts
Bc = c( 0,seq(0.6,3,length.out=nz), array(0, p-nz))
covr1=(1- rho1)*diag(nz) +  array(rho1,c(nz,nz))
covr3=(1- rho3)*diag(p-nz) +  array(rho3,c(p-nz,p-nz))
covr2=array(rho2,c(nz,p-nz))
covr=rbind(cbind(covr1,covr2),cbind(t(covr2),covr3))
covE = eigen(covr)
covsq = covE$vectors %*% diag(sqrt(covE$values)) %*% t(covE$vectors) #
K = 10   ## An initial reasonable choice for number of covariates in the model
Xs = matrix( rnorm(n*p), nrow = n)
Xn = covsq%*% t(Xs)
X = cbind(array(1, n), t(Xn))
Y = X %*% Bc + rnorm(n)
Bols = sapply(seq(1:(p+1)), function(j) summary(lm(Y~ 0+X[,j]))$coef[,1])
B0 = Bols
if(p > n) {m = round(p - (n/2))}
if(p <=n) m = round(p/2)
ind = which(abs(B0)> sort(abs(B0))[m+1])
sighat = sum((summary(lm(Y~0+X[,union(1,ind)]))$residuals)^2)/(n-length(union(1,ind)))
Z0 = array(0,(p+1))
p = dim(X)[2]-1;  n = dim(X)[1]
choicep <-function(x){
return(x - K + qnorm(0.9)*sqrt(x*(1- x/p)))
}
cp = uniroot(choicep, c(1,K))$root
pr = 0.1
s0 = 1/n
fvalue = dnorm(sqrt(2.1*log(p+1)))
s1  = max(100*s0, pr*s0/((1 - pr)*fvalue));
B0 = rep(0, (p+1))
sig = 1;
nburn =50; niter = 50; nsplit = 1;
pr = cp/p
M12 <- realFunctionC( X, Y, Z0, B0, sig, pr, n, p, s0, s1, nburn, niter, nsplit )
M12$Z[,2:8]
M12$B[,2:8]
nburn =1000; niter = 2000; nsplit = 1;
M12 <- realFunctionC( X, Y, Z0, B0, sig, pr, n, p, s0, s1, nburn, niter, nsplit )
n =  100; p = 99
nz = 5
rho1=0.25;rho2=0.25;rho3=0.25  ### correlation among active, between active and inactive, inactive parts
Bc = c( 0,seq(0.6,3,length.out=nz), array(0, p-nz))
covr1=(1- rho1)*diag(nz) +  array(rho1,c(nz,nz))
covr3=(1- rho3)*diag(p-nz) +  array(rho3,c(p-nz,p-nz))
covr2=array(rho2,c(nz,p-nz))
covr=rbind(cbind(covr1,covr2),cbind(t(covr2),covr3))
covE = eigen(covr)
covsq = covE$vectors %*% diag(sqrt(covE$values)) %*% t(covE$vectors) #
K = 10   ## An initial reasonable choice for number of covariates in the model
Xs = matrix( rnorm(n*p), nrow = n)
Xn = covsq%*% t(Xs)
X = cbind(array(1, n), t(Xn))
Y = X %*% Bc + rnorm(n)
Bols = sapply(seq(1:(p+1)), function(j) summary(lm(Y~ 0+X[,j]))$coef[,1])
B0 = Bols
if(p > n) {m = round(p - (n/2))}
if(p <=n) m = round(p/2)
ind = which(abs(B0)> sort(abs(B0))[m+1])
sighat = sum((summary(lm(Y~0+X[,union(1,ind)]))$residuals)^2)/(n-length(union(1,ind)))
Z0 = array(0,(p+1))
p = dim(X)[2]-1;  n = dim(X)[1]
choicep <-function(x){
return(x - K + qnorm(0.9)*sqrt(x*(1- x/p)))
}
cp = uniroot(choicep, c(1,K))$root
pr = 0.1
s0 = 1/n
fvalue = dnorm(sqrt(2.1*log(p+1)))
s1  = max(100*s0, pr*s0/((1 - pr)*fvalue));
B0 = rep(0, (p+1))
sig = 1;
nburn =1000; niter = 2000; nsplit = 1;
nburn =1000; niter = 3000; nsplit = 1;
pr = cp/p
start.time = Sys.time()
M12 <- realFunctionC( X, Y, Z0, B0, sig, pr, n, p, s0, s1, nburn, niter, nsplit )
end.time = Sys.time()
run.time = as.numeric(difftime(end.time, start.time, units = 'secs'))
print(run.time)
library(devtools)
install.packages( c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages("devtools")
install.packages("roxygen2")
install.packages("testthat")
install.packages("knitr")
install.packages("knitr")
devtools::install_github("hadley/devtools")
library(devtools)
has_devel()
library(devtools)
has_devel()
devtools::install_github("hadley/devtools")
has_devel()
install.packages("devtools")
devtools::install_github("hadley/devtools")
devtools::install_github("hadley/devtools")
has_devel()
library("devtools", lib.loc="~/Library/R/3.3/library")
has_devel()
install.packages("RcppEigen")
install.packages("Rcpp")
library("Rcpp")
sourceCpp("/Users/Qingyan/Documents/research/workCpp/testNewT.cpp")
RuntimeNPRcpp <- numeric(5)
n =  100; p = 499
nz = 5
library("Rcpp")
library("Rcpp")
sourceCpp("~/Documents/research/workCpp/testFinalT.cpp")
sourceCpp("~/Documents/research/workCpp/testFinalT.cpp")
n =  100; p = 499
nz = 5
rho1=0.25;rho2=0.5;rho3=0.75  ### correlation among active, between active and inactive, inactive parts
Bc = c( 0,seq(0.6,3, length.out = 5), array(0, p-nz))
covr1=(1- rho1)*diag(nz) +  array(rho1,c(nz,nz))
covr3=(1- rho3)*diag(p-nz) +  array(rho3,c(p-nz,p-nz))
covr2=array(rho2,c(nz,p-nz))
covr=rbind(cbind(covr1,covr2),cbind(t(covr2),covr3))
covE = eigen(covr)
covsq = covE$vectors %*% diag(sqrt(covE$values)) %*% t(covE$vectors) #
K = 10   ## An initial reasonable choice for number of covariates in the model
Xs = matrix( rnorm(n*p), nrow = n)
Xn = covsq%*% t(Xs)
X = cbind(array(1, n), t(Xn))
Y = X %*% Bc + rnorm(n)
Bols = sapply(seq(1:(p+1)), function(j) summary(lm(Y~ 0+X[,j]))$coef[,1])
B0 = Bols
if(p > n) {m = round(p - (n/2))}
if(p <=n) m = round(p/2)
ind = which(abs(B0)> sort(abs(B0))[m+1])
sighat = sum((summary(lm(Y~0+X[,union(1,ind)]))$residuals)^2)/(n-length(union(1,ind)))
Z0 = array(0,(p+1))
p = dim(X)[2]-1;  n = dim(X)[1]
choicep <-function(x){
return(x - K + qnorm(0.9)*sqrt(x*(1- x/p)))
}
cp = uniroot(choicep, c(1,K))$root
pr = 0.1
s0 = 1/n
nu  = 5
fvalue = dt(sqrt(2.1*log(p+1)), df = nu)
s1  = max(100*s0, pr*s0/((1 - pr)*fvalue));
B0 = rep(0, (p+1))
sig = sighat;
nburn =1000; niter = 3000; nsplit = 1;
pr = cp/p
M12 <- realFunctionT( X, Y, Z0, B0, sig, pr, n, p, nu, s0, s1, nburn, niter, nsplit, Fast = 1 )
apply(M12$Z[1001:4000,], 2, mean)
apply(M12$B[1001:4000,], 2, mean)
round( apply(M12$B[1001:4000,], 2, mean), 5 )
round( apply(M12$Z[1001:4000,], 2, mean), 5 )
setwd("~/Documents/rpackage")
install.packages("~/Documents/rpackage/basad_1.0.tar.gz" )
setwd("~/Documents/rpackage/basad")
library(devtools)
install()
library(basad)
setwd("~/Documents/rpackage/basad")
install()
library("devtools")
install()
n =  100; p = 99
nz = 5
rho1=0.25;rho2=0.25;rho3=0.25  ### correlation among active, between active and inactive, inactive parts
Bc = c( 0,seq(0.6,3,length.out=nz), array(0, p-nz))
covr1=(1- rho1)*diag(nz) +  array(rho1,c(nz,nz))
covr3=(1- rho3)*diag(p-nz) +  array(rho3,c(p-nz,p-nz))
covr2=array(rho2,c(nz,p-nz))
covr=rbind(cbind(covr1,covr2),cbind(t(covr2),covr3))
###covr = (1- rho)*diag(p) +  array(rho,c(p,p)) #Covariance of covariates
covE = eigen(covr)
covsq = covE$vectors %*% diag(sqrt(covE$values)) %*% t(covE$vectors) #
K = 10   ## An initial reasonable choice for number of covariates in the model
Xs = matrix( rnorm(n*p), nrow = n)
Xn = covsq%*% t(Xs)
X = cbind(array(1, n), t(Xn))
Y = X %*% Bc + rnorm(n)
#X <- X[, 2:100]
X
Y
basad(x = X, y = Y)
library("basad")
basad(x = X, y = Y)
